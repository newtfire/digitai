
// ==== Generated by XSLT Transformation ====

// 1. SETUP: Create Constraints for Performance and Data Integrity
 CREATE CONSTRAINT IF NOT EXISTS FOR (d:Document) REQUIRE d.title IS UNIQUE;
 CREATE CONSTRAINT IF NOT EXISTS FOR (s:Section) REQUIRE s.id IS UNIQUE;
 CREATE CONSTRAINT IF NOT EXISTS FOR (spec:Specification) REQUIRE spec.name IS UNIQUE;

// 2. LOAD AND PROCESS: Load the JSON and start the recursive import
CALL apoc.load.json("https://raw.githubusercontent.com/newtfire/digitai/refs/heads/ebb-json/RAG/sandbox/sandboxTest.json") YIELD value as doc_data

// Create the root Document node
MERGE (doc:Document {title: 'SOURCE XML AS BASIS FOR A KNOWLEDGE GRAPH'})


  FOREACH ( part_data_1  IN  doc_data . CONTAINS_PARTS  | 
  	 MERGE (part:Part {name: part_data_1.PART}) 
  	 MERGE ( doc )-[: HAS_PART ]->(part) 
 	 FOREACH ( chapter_data_2  IN  part_data_1 . CONTAINS_CHAPTERS  | 
 	 	 MERGE (chapter:Chapter {chapter: chapter_data_2.CHAPTER}) SET chapter.sequence = chapter_data_2.SEQUENCE, chapter.title = chapter_data_2.CHAPTER 
 	 	 MERGE ( part )-[: HAS_CHAPTER ]->( chapter ) 
 		 FOREACH ( section_data_3  IN  chapter_data_2 . CONTAINS_SECTIONS  | 
 		 	 MERGE (section:Section {section: section_data_3.SECTION}) SET section.sequence = section_data_3.SEQUENCE, section.title = section_data_3.SECTION 
 		 	 MERGE ( chapter )-[: HAS_SECTION ]->( section ) 
 			 FOREACH ( subsection_data_4  IN  section_data_3 . CONTAINS_SUBSECTIONS  | 
 			 	 MERGE (subsection:Subsection {subsection: subsection_data_4.SUBSECTION}) SET subsection.sequence = subsection_data_4.SEQUENCE, subsection.title = subsection_data_4.SECTION 
 			 	 MERGE ( section )-[: HAS_SUBSECTION ]->( subsection ) 
 				 FOREACH ( nestedsubsection_data_5  IN  subsection_data_4 . CONTAINS_NESTED_SUBSECTIONS  | 
 				 	 MERGE (nestedsubsection:Nestedsubsection {nestedsubsection: nestedsubsection_data_5.NESTEDSUBSECTION}) SET nestedsubsection.sequence = nestedsubsection_data_5.SEQUENCE, nestedsubsection.title = nestedsubsection_data_5.SECTION 
 				 	 MERGE ( subsection )-[: HAS_NESTED_SUBSECTION ]->( nestedsubsection ) 
 					 FOREACH ( paragraph_data_6  IN  nestedsubsection_data_5 . CONTAINS_PARAS  | 
 					 	 MERGE (paragraph:Para {paragraph: paragraph_data_6.PARASTRING}) SET paragraph.sequence = paragraph_data_6.SEQUENCE, paragraph.spec_references = [x IN paragraph_data_6.CONTAINS_SPECLISTS.SPECLIST WHERE x IS NOT NULL | x.LINK_TO_SPEC], paragraph.text = paragraph_data_6.PARASTRING 
 					 	 MERGE ( nestedsubsection )-[: HAS_PARAGRAPH ]->( paragraph )
 						 FOREACH ( specgrp_data_7  IN  paragraph_data_6 .CONTAINS_SPECGRPS | 
 						 	 CREATE ( specgrp_7 : Specgrp ) 
 						 	 MERGE ( paragraph )-[:HAS_SPECGRP]->( specgrp_7 ) 
 						 	 FOREACH ( specification_item_7  IN  specgrp_data_7 .SPECGRP | 
 						 	 	 MERGE ( specification_7 : Spec  {name:  specification_item_7 .SPEC}) 
 						 	 	 MERGE ( specgrp_7 )-[:HAS_SPEC]->( specification_7 ) 
 								 FOREACH ( contentmodel_data_8  IN  specification_item_7 . HAS_CONTENT  | 
 								 	 MERGE (contentmodel:Content {name: contentmodel_data_8.CONTENT}) SET contentmodel.rule = contentmodel_data_8.RULE 
 								 	 MERGE ( specification_7 )-[: DEFINES_CONTENT_MODEL ]->( contentmodel ) 
 								 ) 
 								 FOREACH ( terminal_paragraph_data_8  IN  specification_item_7 . CONTAINS_TERMINAL_PARAS  | 
 								 	 CREATE (terminal_paragraph:Para) SET terminal_paragraph.sequence = terminal_paragraph_data_8.SEQUENCE, terminal_paragraph.text = terminal_paragraph_data_8.PARASTRING 
 								 	 MERGE ( specification_7 )-[: HAS_TERMINAL_PARA ]->(terminal_paragraph) 
 								 ) 
 						 	 ) 
 						 )
 					 ) 
 				 ) 
 				 FOREACH ( paragraph_data_5  IN  subsection_data_4 . CONTAINS_PARAS  | 
 				 	 MERGE (paragraph:Para {paragraph: paragraph_data_5.PARASTRING}) SET paragraph.sequence = paragraph_data_5.SEQUENCE, paragraph.spec_references = [x IN paragraph_data_5.CONTAINS_SPECLISTS.SPECLIST WHERE x IS NOT NULL | x.LINK_TO_SPEC], paragraph.text = paragraph_data_5.PARASTRING 
 				 	 MERGE ( subsection )-[: HAS_PARAGRAPH ]->( paragraph )
 					 FOREACH ( specgrp_data_6  IN  paragraph_data_5 .CONTAINS_SPECGRPS | 
 					 	 CREATE ( specgrp_6 : Specgrp ) 
 					 	 MERGE ( paragraph )-[:HAS_SPECGRP]->( specgrp_6 ) 
 					 	 FOREACH ( specification_item_6  IN  specgrp_data_6 .SPECGRP | 
 					 	 	 MERGE ( specification_6 : Spec  {name:  specification_item_6 .SPEC}) 
 					 	 	 MERGE ( specgrp_6 )-[:HAS_SPEC]->( specification_6 ) 
 							 FOREACH ( contentmodel_data_7  IN  specification_item_6 . HAS_CONTENT  | 
 							 	 MERGE (contentmodel:Content {name: contentmodel_data_7.CONTENT}) SET contentmodel.rule = contentmodel_data_7.RULE 
 							 	 MERGE ( specification_6 )-[: DEFINES_CONTENT_MODEL ]->( contentmodel ) 
 							 ) 
 							 FOREACH ( terminal_paragraph_data_7  IN  specification_item_6 . CONTAINS_TERMINAL_PARAS  | 
 							 	 CREATE (terminal_paragraph:Para) SET terminal_paragraph.sequence = terminal_paragraph_data_7.SEQUENCE, terminal_paragraph.text = terminal_paragraph_data_7.PARASTRING 
 							 	 MERGE ( specification_6 )-[: HAS_TERMINAL_PARA ]->(terminal_paragraph) 
 							 ) 
 					 	 ) 
 					 )
 				 ) 
 			 ) 
 			 FOREACH ( paragraph_data_4  IN  section_data_3 . CONTAINS_PARAS  | 
 			 	 MERGE (paragraph:Para {paragraph: paragraph_data_4.PARASTRING}) SET paragraph.sequence = paragraph_data_4.SEQUENCE, paragraph.spec_references = [x IN paragraph_data_4.CONTAINS_SPECLISTS.SPECLIST WHERE x IS NOT NULL | x.LINK_TO_SPEC], paragraph.text = paragraph_data_4.PARASTRING 
 			 	 MERGE ( section )-[: HAS_PARAGRAPH ]->( paragraph )
 				 FOREACH ( specgrp_data_5  IN  paragraph_data_4 .CONTAINS_SPECGRPS | 
 				 	 CREATE ( specgrp_5 : Specgrp ) 
 				 	 MERGE ( paragraph )-[:HAS_SPECGRP]->( specgrp_5 ) 
 				 	 FOREACH ( specification_item_5  IN  specgrp_data_5 .SPECGRP | 
 				 	 	 MERGE ( specification_5 : Spec  {name:  specification_item_5 .SPEC}) 
 				 	 	 MERGE ( specgrp_5 )-[:HAS_SPEC]->( specification_5 ) 
 						 FOREACH ( contentmodel_data_6  IN  specification_item_5 . HAS_CONTENT  | 
 						 	 MERGE (contentmodel:Content {name: contentmodel_data_6.CONTENT}) SET contentmodel.rule = contentmodel_data_6.RULE 
 						 	 MERGE ( specification_5 )-[: DEFINES_CONTENT_MODEL ]->( contentmodel ) 
 						 ) 
 						 FOREACH ( terminal_paragraph_data_6  IN  specification_item_5 . CONTAINS_TERMINAL_PARAS  | 
 						 	 CREATE (terminal_paragraph:Para) SET terminal_paragraph.sequence = terminal_paragraph_data_6.SEQUENCE, terminal_paragraph.text = terminal_paragraph_data_6.PARASTRING 
 						 	 MERGE ( specification_5 )-[: HAS_TERMINAL_PARA ]->(terminal_paragraph) 
 						 ) 
 				 	 ) 
 				 )
 			 ) 
 		 ) 
 		 FOREACH ( paragraph_data_3  IN  chapter_data_2 . CONTAINS_PARAS  | 
 		 	 MERGE (paragraph:Para {paragraph: paragraph_data_3.PARASTRING}) SET paragraph.sequence = paragraph_data_3.SEQUENCE, paragraph.spec_references = [x IN paragraph_data_3.CONTAINS_SPECLISTS.SPECLIST WHERE x IS NOT NULL | x.LINK_TO_SPEC], paragraph.text = paragraph_data_3.PARASTRING 
 		 	 MERGE ( chapter )-[: HAS_PARAGRAPH ]->( paragraph )
 			 FOREACH ( specgrp_data_4  IN  paragraph_data_3 .CONTAINS_SPECGRPS | 
 			 	 CREATE ( specgrp_4 : Specgrp ) 
 			 	 MERGE ( paragraph )-[:HAS_SPECGRP]->( specgrp_4 ) 
 			 	 FOREACH ( specification_item_4  IN  specgrp_data_4 .SPECGRP | 
 			 	 	 MERGE ( specification_4 : Spec  {name:  specification_item_4 .SPEC}) 
 			 	 	 MERGE ( specgrp_4 )-[:HAS_SPEC]->( specification_4 ) 
 					 FOREACH ( contentmodel_data_5  IN  specification_item_4 . HAS_CONTENT  | 
 					 	 MERGE (contentmodel:Content {name: contentmodel_data_5.CONTENT}) SET contentmodel.rule = contentmodel_data_5.RULE 
 					 	 MERGE ( specification_4 )-[: DEFINES_CONTENT_MODEL ]->( contentmodel ) 
 					 ) 
 					 FOREACH ( terminal_paragraph_data_5  IN  specification_item_4 . CONTAINS_TERMINAL_PARAS  | 
 					 	 CREATE (terminal_paragraph:Para) SET terminal_paragraph.sequence = terminal_paragraph_data_5.SEQUENCE, terminal_paragraph.text = terminal_paragraph_data_5.PARASTRING 
 					 	 MERGE ( specification_4 )-[: HAS_TERMINAL_PARA ]->(terminal_paragraph) 
 					 ) 
 			 	 ) 
 			 )
 		 ) 
 	 ) 
  )
;

// STEP 2: Create sequential :NEXT relationships

 // Link sequential : Para  nodes within each : Spec 
 MATCH (parent:Spec)-[:HAS_TERMINAL_PARA]->(child:Para)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Nestedsubsection  nodes within each : Subsection 
 MATCH (parent:Subsection)-[:HAS_NESTED_SUBSECTION]->(child:Nestedsubsection)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Para  nodes within each : Subsection 
 MATCH (parent:Subsection)-[:HAS_PARAGRAPH]->(child:Para)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Subsection  nodes within each : Section 
 MATCH (parent:Section)-[:HAS_SUBSECTION]->(child:Subsection)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Para  nodes within each : Section 
 MATCH (parent:Section)-[:HAS_PARAGRAPH]->(child:Para)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Section  nodes within each : Chapter 
 MATCH (parent:Chapter)-[:HAS_SECTION]->(child:Section)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Para  nodes within each : Chapter 
 MATCH (parent:Chapter)-[:HAS_PARAGRAPH]->(child:Para)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Chapter  nodes within each : Part 
 MATCH (parent:Part)-[:HAS_CHAPTER]->(child:Chapter)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Part  nodes within each : Document 
 MATCH (parent:Document)-[:HAS_PART]->(child:Part)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ; 
 // Link sequential : Para  nodes within each : Nestedsubsection 
 MATCH (parent:Nestedsubsection)-[:HAS_PARAGRAPH]->(child:Para)             WHERE child.sequence IS NOT NULL             WITH parent, child ORDER BY child.sequence             WITH parent, collect(child) AS ordered_children             UNWIND range(0, size(ordered_children) - 2) AS i             WITH ordered_children[i] AS n1, ordered_children[i+1] AS n2             MERGE (n1)-[:NEXT]->(n2) ;