
// ==== Generated by XSLT Transformation ====

// 1. SETUP: Create Constraints for Performance and Data Integrity
 CREATE CONSTRAINT IF NOT EXISTS FOR (d:Document) REQUIRE d.title IS UNIQUE;
 CREATE CONSTRAINT IF NOT EXISTS FOR (s:Section) REQUIRE s.id IS UNIQUE;
 CREATE CONSTRAINT IF NOT EXISTS FOR (spec:Specification) REQUIRE spec.name IS UNIQUE;

// 2. LOAD AND PROCESS: Load the JSON and start the recursive import
CALL apoc.load.json("file:///sandboxTest.json") YIELD value

// Create the root Document node
MERGE (doc:Document {title: 'SOURCE XML AS BASIS FOR A KNOWLEDGE GRAPH'})


	FOREACH (part_data IN doc_data.CONTAINS_PARTS |
	 MERGE (part:Part {name: part_data.PART}) 
	 
	 MERGE (doc)-[:HAS_PART]->(part) 
	 
	FOREACH (chapter_data IN part_data.CONTAINS_CHAPTERS |
	 MERGE (chapter:Chapter {chapter: chapter_data.CHAPTER}) SET chapter_data.sequence = chapter.SEQUENCE, chapter_data.title = chapter.CHAPTER 
	 
	 MERGE (part)-[:HAS_CHAPTER]->(chapter) 
	 
	FOREACH (section_data IN chapter_data.CONTAINS_SECTIONS |
	 MERGE (section:Section {section: section_data.SECTION}) SET section_data.sequence = section.SEQUENCE, section_data.title = section.SECTION 
	 
	 MERGE (chapter)-[:HAS_SECTION]->(section) 
	 
	FOREACH (subsection_data IN section_data.CONTAINS_SUBSECTIONS |
	 MERGE (subsection:Subsection {subsection: subsection_data.SUBSECTION}) SET subsection_data.sequence = subsection.SEQUENCE, subsection_data.title = subsection.SECTION 
	 
	 MERGE (section)-[:HAS_SUBSECTION]->(subsection) 
	 
	FOREACH (nestedsubsection_data IN subsection_data.CONTAINS_NESTED_SUBSECTIONS |
	 MERGE (nestedsubsection:Nestedsubsection {nestedsubsection: nestedsubsection_data.NESTEDSUBSECTION}) SET nestedsubsection_data.sequence = nestedsubsection.SEQUENCE, nestedsubsection_data.title = nestedsubsection.SECTION 
	 
	 MERGE (subsection)-[:HAS_NESTED_SUBSECTION]->(nestedsubsection) 
	 
	FOREACH (paragraph_data IN nestedsubsection_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (nestedsubsection)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
	FOREACH (contentmodel_data IN specification_data.HAS_CONTENT |
	 MERGE (contentmodel:Content {name: contentmodel_data.CONTENT}) SET contentmodel_data.rule = name.RULE 
	 
	 MERGE (specification)-[:DEFINES_CONTENT_MODEL]->(contentmodel) 
	 
	FOREACH (paragraph_data IN specification_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (specification)-[:HAS_PARAGRAPH]->(paragraph) 
	 
 // Link sequential : Para  nodes 
 	MATCH (n:Para)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
 // Link sequential : Nestedsubsection  nodes 
 	MATCH (n:Nestedsubsection)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
	FOREACH (paragraph_data IN subsection_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (subsection)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
	FOREACH (contentmodel_data IN specification_data.HAS_CONTENT |
	 MERGE (contentmodel:Content {name: contentmodel_data.CONTENT}) SET contentmodel_data.rule = name.RULE 
	 
	 MERGE (specification)-[:DEFINES_CONTENT_MODEL]->(contentmodel) 
	 
	FOREACH (paragraph_data IN specification_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (specification)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
 // Link sequential : Para  nodes 
 	MATCH (n:Para)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
 // Link sequential : Subsection  nodes 
 	MATCH (n:Subsection)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
	FOREACH (paragraph_data IN section_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (section)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
	FOREACH (contentmodel_data IN specification_data.HAS_CONTENT |
	 MERGE (contentmodel:Content {name: contentmodel_data.CONTENT}) SET contentmodel_data.rule = name.RULE 
	 
	 MERGE (specification)-[:DEFINES_CONTENT_MODEL]->(contentmodel) 
	 
	FOREACH (paragraph_data IN specification_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (specification)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
 // Link sequential : Para  nodes 
 	MATCH (n:Para)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
 // Link sequential : Section  nodes 
 	MATCH (n:Section)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
	FOREACH (paragraph_data IN chapter_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (chapter)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
	FOREACH (contentmodel_data IN specification_data.HAS_CONTENT |
	 MERGE (contentmodel:Content {name: contentmodel_data.CONTENT}) SET contentmodel_data.rule = name.RULE 
	 
	 MERGE (specification)-[:DEFINES_CONTENT_MODEL]->(contentmodel) 
	 
	FOREACH (paragraph_data IN specification_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (specification)-[:HAS_PARAGRAPH]->(paragraph) 
	 
	FOREACH (speclist_data IN paragraph_data.CONTAINS_SPECLISTS |
	 MERGE (speclist:Speclist {name: speclist_data.SPECLIST}) 
	 
	 MERGE (paragraph)-[:HAS_SPECLIST]->(speclist) 
	 
	FOREACH (link_to_spec_data IN speclist_data.LINK_TO_SPEC |
	 MERGE (link_to_spec:LinkToSpec {name: link_to_spec_data.LINK_TO_SPEC}) 
	 
	 MERGE (speclist)-[:REFERS_TO_SPECIFICATION]->(link_to_spec) 
	 
	FOREACH (specgrp_data IN paragraph_data.CONTAINS_SPECGRPS |
	 MERGE (specgrp:Specgrp {name: specgrp_data.SPECGRP}) SET specgrp_data.title = name.SPECGRP 
	 
	 MERGE (paragraph)-[:HAS_SPECGRP]->(specgrp) 
	 
	FOREACH (specification_data IN specgrp_data.CONTAINS_SPECS |
	 MERGE (specification:Spec {name: specification_data.SPEC}) 
	 
	 MERGE (specgrp)-[:HAS_SPEC]->(specification) 
	 
	FOREACH (contentmodel_data IN specification_data.HAS_CONTENT |
	 MERGE (contentmodel:Content {name: contentmodel_data.CONTENT}) SET contentmodel_data.rule = name.RULE 
	 
	 MERGE (specification)-[:DEFINES_CONTENT_MODEL]->(contentmodel) 
	 
	FOREACH (paragraph_data IN specification_data.CONTAINS_PARAS |
	 MERGE (paragraph:Para {paragraph: paragraph_data.PARASTRING}) SET paragraph_data.sequence = paragraph.SEQUENCE 
	 
	 MERGE (specification)-[:HAS_PARAGRAPH]->(paragraph) 
	 
 // Link sequential : Para  nodes 
 	MATCH (n:Para)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
 // Link sequential : Chapter  nodes 
 	MATCH (n:Chapter)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	 
 // Link sequential : Part  nodes 
 	MATCH (n:Part)
		WHERE n.sequence IS NOT NULL
		WITH n.sequence, n
		ORDER BY n.sequence
		WITH collect(n) AS ordered_nodes
		UNWIND range(0, size(ordered_nodes) - 2) AS i
			WITH ordered_nodes[i] AS n1, ordered_nodes[i+1] AS n2
			MERGE (n1)-[:NEXT]->(n2)
	